// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

contract Voting_modifier{

    address public owner;
    
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

}


contract Voting is Voting_modifier{
    // 특정 사용자가 제안을 실행하고 이 제안에 동의하는 사람들을 표시하는 방식으로 동작

    mapping(uint => Proposal) proposal_list;
    mapping(address => uint) my_proposal_list;
    uint public total_proposal_count  = 0;
    uint require_count = 50;// 얼마만큼의 동의를 얻어야 수행이 가능한지를 표시, 일종의 목표값
   

    constructor(){
        owner = msg.sender; // 특정 조건값을 바꾸는데에는 주인 계정만 사용이 가능하게 하기 위해
    }

    enum Status{
        end, playing
    }

    struct Proposal{
        address Starter_user;
        address[] aggred_User; // 동의한 주소값
        uint count;
        string title; // 어떤 제의인지 
        Status status;
    }

    function make_proposal (string memory _title) public {
        // 단순하게 제안서를 받고 제안을 하는 상황
        // 이 부분에서 이전에 했던 제안, 이미 있는 제안은 거절해야 하는데 이 부분을 어떻게 처리할지 감이 오지를 않음
        // 단순히 한 사용자당 하나의 제안만을 다룰수 있는 방향으로 진행을 한다??
        address[] memory test;
        proposal_list[total_proposal_count] = Proposal({
            Starter_user : msg.sender,
            count : 0,
            aggred_User :  test,
            title : _title,
            status : Status.playing
        });
        my_proposal_list[msg.sender]++;
        total_proposal_count++;
    }

    function upgrade_proposal(uint index) public {
        Proposal storage pos = proposal_list[index];

        require(pos.status == Status.playing,"Not Playing!!");
        require(pos.Starter_user != msg.sender,"can't upgrade mySelf");

        pos.aggred_User.push(msg.sender);
        pos.count ++;
    }


    function change_require_count(uint total_user) public onlyOwner {
        // 총 사용자중 30퍼센트가 동의를 해야한다는 느낌
        if(require_count < total_user / 30){
            require_count = total_user/ 30;
        }
    }

    function done_Proposal(uint index) public {
        Proposal storage pos = proposal_list[index];
        require(pos.count >= require_count,"Not Enough Count");
        pos.status = Status.end;
        total_proposal_count--;
    }

    function view_address_Proposal() public view returns(Proposal[] memory){
        // 특정 주소에 해당 하는 데이터를 가져오는 함수
        // 마이 페이지 부분에 구현이 될 예정
        Proposal[] memory return_value = new Proposal[](my_proposal_list[msg.sender]);
        uint index = 0;
        for(uint256 i = 0;  i<total_proposal_count; i++){
            Proposal memory check = proposal_list[i];
            if(check.Starter_user == msg.sender){
                    return_value[index] = check;
            }
        }
        return return_value;
    }

    function view_Proposal(uint256 index) public view returns(Proposal memory){
        // 특정 index에 해당하는 Proposal을 확인하는 함수
        Proposal memory pos = proposal_list[index];
        require(pos.status == Status.playing || pos.status == Status.end);
        return proposal_list[index];
    }

    function view_total_Proposal() public view returns(Proposal[] memory){
        // 전체 제안을 보는 용도
         Proposal[] memory return_value = new Proposal[](total_proposal_count);
         for(uint256 i=0; i<total_proposal_count; i++){
             Proposal memory check = proposal_list[i];
             return_value[i] = check;
         }
         return return_value;
    }
    
}

